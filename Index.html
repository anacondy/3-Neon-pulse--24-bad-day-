<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON PULSE - CRT SYSTEM</title>
    <style>
        /* --- RETRO CRT STYLING ---
           Imports VT323 font for that terminal look.
           Defines variables for the specific phosphor green color.
        */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --phosphor-main: #39ff14;
            --phosphor-dim: #1b8a0a;
            --phosphor-bright: #ccffcc;
            --danger-color: #ff3333; /* For obstacles */
            --bg-color: #050505;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden; /* No scrolling allowed */
            font-family: 'VT323', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* Main Container for CRT effects */
        #crt-frame {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: var(--bg-color);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* The blur creates the 'glow' bleeding effect common on old monitors */
            filter: blur(0.6px) contrast(1.2) brightness(1.15);
        }

        /* --- CRT OVERLAYS --- */
        
        /* 1. Scanlines: Horizontal lines pattern */
        .scanlines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.3) 50%,
                rgba(0,0,0,0.3)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* 2. Vignette: Darkens corners to simulate curved tube glass */
        .vignette {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(
                circle,
                rgba(0,0,0,0) 55%,
                rgba(0,0,0,0.5) 85%,
                rgba(0,0,0,0.95) 100%
            );
            pointer-events: none;
            z-index: 11;
        }

        /* 3. RGB Shift: Slight chromatic aberration on edges */
        .rgb-shift {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 12;
            mix-blend-mode: screen;
            opacity: 0.1;
            background: linear-gradient(90deg, rgba(255,0,0,0.1), rgba(0,255,0,0.1), rgba(0,0,255,0.1));
            background-size: 3px 100%;
        }

        /* --- UI ELEMENTS --- */

        .ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header-stats {
            display: flex;
            justify-content: space-between;
            color: var(--phosphor-main);
            font-size: 1.5rem;
            text-shadow: 0 0 5px var(--phosphor-dim);
            text-transform: uppercase;
        }

        .terminal-text {
            color: var(--phosphor-main);
            text-shadow: 0 0 8px var(--phosphor-main);
        }

        /* Start Screen Overlay */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            text-align: center;
            color: var(--phosphor-main);
            pointer-events: auto; /* Allow clicking button */
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            letter-spacing: 8px;
            text-shadow: 0 0 15px var(--phosphor-main);
            animation: pulseText 2s infinite ease-in-out;
        }

        @keyframes pulseText {
            0% { text-shadow: 0 0 10px var(--phosphor-main); opacity: 0.9; }
            50% { text-shadow: 0 0 25px var(--phosphor-main); opacity: 1; }
            100% { text-shadow: 0 0 10px var(--phosphor-main); opacity: 0.9; }
        }

        .start-btn {
            margin-top: 30px;
            background: transparent;
            border: 2px solid var(--phosphor-main);
            color: var(--phosphor-main);
            padding: 15px 40px;
            font-family: 'VT323', monospace;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 0 10px var(--phosphor-dim);
            transition: 0.2s;
            text-transform: uppercase;
        }

        .start-btn:hover {
            background: var(--phosphor-main);
            color: #000;
            box-shadow: 0 0 30px var(--phosphor-main);
        }

        .blink { animation: blinker 0.8s step-end infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* Mobile specific adjustments */
        @media (max-width: 600px) {
            h1 { font-size: 3rem; }
            .header-stats { font-size: 1.2rem; }
        }

    </style>
</head>
<body>

<div id="crt-frame">
    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div class="rgb-shift"></div>

    <!-- HUD Layer -->
    <div class="ui-layer">
        <div class="header-stats">
            <div>DIST: <span id="dist-display">0000m</span></div>
            <div>STATUS: <span id="status-display" class="blink">STANDBY</span></div>
        </div>
        <div style="text-align: center; margin-bottom: 20px; opacity: 0.6; font-size: 1.2rem;">
            // TAP TO INVERT POLARITY //
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Menu Overlay -->
    <div id="menu-overlay">
        <h1>NEON PULSE</h1>
        <p style="font-size: 1.4rem; margin-top: 10px;">Gravity Switcher v2.0</p>
        <p style="opacity: 0.7; max-width: 80%;">Navigate the data stream. Avoid corrupted sectors.</p>
        <button class="start-btn" id="start-btn">INITIALIZE_SYSTEM</button>
    </div>
</div>

<script>
    /**
     * NEON PULSE - Interactive Code Breakdown
     * ---------------------------------------
     * 1. AudioEngine: Uses OscillatorNodes to create 'electric' synthesis.
     * 2. Physics: Simple gravity inversion logic.
     * 3. Environment: Perspective grid and particle streams to simulate speed.
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('start-btn');
    const menuOverlay = document.getElementById('menu-overlay');
    const distDisplay = document.getElementById('dist-display');
    const statusDisplay = document.getElementById('status-display');

    // -- GAME STATE --
    let width, height;
    let isActive = false;
    let frameCount = 0;
    let distance = 0;
    let speed = 6;
    let lastTime = 0;
    let shakeIntensity = 0; // For screen shake effect

    // -- AUDIO SYSTEM (Procedural) --
    const Audio = {
        ctx: null,
        bgOsc: null,
        bgGain: null,
        
        init() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            
            // Create background hum (Electric Drone)
            this.bgOsc = this.ctx.createOscillator();
            this.bgGain = this.ctx.createGain();
            
            // Use Sawtooth for a harsh, "electric" buzzing sound
            this.bgOsc.type = 'sawtooth'; 
            this.bgOsc.frequency.value = 55; // Low A note
            
            // Lowpass filter to muffle the harshness, making it ambient
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 200;

            this.bgOsc.connect(filter);
            filter.connect(this.bgGain);
            this.bgGain.connect(this.ctx.destination);
            
            this.bgGain.gain.value = 0; // Start silent
            this.bgOsc.start();
        },

        startMusic() {
            if(!this.ctx) return;
            // Ramp up volume
            this.bgGain.gain.setTargetAtTime(0.08, this.ctx.currentTime, 1);
        },

        playJump() {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        },

        playCrash() {
            if(!this.ctx) return;
            // White noise burst
            const bufferSize = this.ctx.sampleRate * 0.5;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);

            noise.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
            
            // Stop background hum temporarily
            this.bgGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
        }
    };

    // -- ENTITIES --

    const player = {
        x: 100,
        y: 0,
        size: 20,
        vy: 0,
        gravity: 0.8,
        onGround: false,
        isTop: false, // Is gravity inverted?
        color: '#39ff14',
        trail: [] // Stores previous positions for the "Tail" effect
    };

    let obstacles = [];
    let particles = []; // Ambient dust
    let sparks = []; // Explosion/Jump sparks

    // -- RESIZE & INIT --
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        player.y = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // -- INPUT --
    function handleInput(e) {
        if (!isActive) return;
        e.preventDefault(); // Prevent double firing on some touch devices
        
        // Flip Gravity Logic
        player.gravity *= -1;
        player.isTop = !player.isTop;
        
        // Visual & Audio feedback
        Audio.playJump();
        createSparks(player.x, player.y, 10, '#ccffcc'); // White sparks on jump
    }

    document.addEventListener('mousedown', handleInput);
    document.addEventListener('touchstart', handleInput, {passive: false});
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') handleInput(e);
    });

    // -- PARTICLES SYSTEM --
    
    // 1. Ambient Dust (Speed lines)
    function spawnDust() {
        if (particles.length < 50) {
            particles.push({
                x: width + Math.random() * 200,
                y: Math.random() * height,
                w: Math.random() * 40 + 10, // Long width for speed effect
                h: 1,
                speed: Math.random() * 5 + 5,
                alpha: Math.random() * 0.3
            });
        }
    }

    // 2. Sparks (Explosions/Jumps)
    function createSparks(x, y, count, color) {
        for(let i=0; i<count; i++) {
            sparks.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color || '#39ff14'
            });
        }
    }

    // -- GAME LOOP --
    
    function resetGame() {
        player.y = height / 2;
        player.vy = 0;
        player.gravity = 0.8; // Reset gravity
        player.isTop = false;
        player.trail = [];
        obstacles = [];
        sparks = [];
        distance = 0;
        speed = 8;
        shakeIntensity = 0;
        isActive = true;
        statusDisplay.innerText = "ONLINE";
        statusDisplay.classList.remove('blink');
        statusDisplay.style.color = "var(--phosphor-main)";
        Audio.startMusic();
    }

    function gameOver() {
        isActive = false;
        shakeIntensity = 20; // Big shake
        Audio.playCrash();
        createSparks(player.x, player.y, 50, '#ff3333'); // Red sparks
        statusDisplay.innerText = "CRITICAL FAIL";
        statusDisplay.style.color = "red";
        statusDisplay.classList.add('blink');
        
        setTimeout(() => {
            menuOverlay.style.display = 'flex';
            document.querySelector('#menu-overlay h1').innerText = "SYSTEM CRASH";
            document.querySelector('#menu-overlay p').innerText = "Distance: " + Math.floor(distance) + "m";
            startBtn.innerText = "REBOOT SYSTEM";
        }, 1500);
    }

    function update() {
        if (!isActive) return;

        distance += speed * 0.1;
        speed += 0.001; // Slowly increase speed

        // 1. Player Physics
        player.vy += player.gravity;
        player.y += player.vy;

        // Floor/Ceiling Collision
        const floorY = height - 50;
        const ceilY = 50;

        if (player.y > floorY) {
            player.y = floorY;
            player.vy = 0;
            if(!player.isTop) createSparks(player.x, player.y + player.size/2, 1, '#39ff14'); // Friction sparks
        }
        if (player.y < ceilY) {
            player.y = ceilY;
            player.vy = 0;
            if(player.isTop) createSparks(player.x, player.y - player.size/2, 1, '#39ff14');
        }

        // Update Trail
        player.trail.push({x: player.x, y: player.y});
        if (player.trail.length > 10) player.trail.shift();

        // 2. Obstacles Logic
        // Spawn
        if (frameCount % Math.floor(1000/speed) === 0) {
            const isUp = Math.random() > 0.5;
            obstacles.push({
                x: width,
                y: isUp ? 50 - 20 : height - 50 - 60, // Top or Bottom position
                w: 40,
                h: 80,
                color: '#ff3333'
            });
        }

        // Update Obstacles & Collision
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= speed;

            // Collision AABB
            // Player box (smaller than visual for leniency)
            if (player.x + 10 > obs.x && player.x - 10 < obs.x + obs.w &&
                player.y + 10 > obs.y && player.y - 10 < obs.y + obs.h) {
                gameOver();
            }

            if (obs.x < -100) obstacles.splice(i, 1);
        }

        // 3. Dust Particles
        spawnDust();
        particles.forEach(p => {
            p.x -= p.speed;
            if(p.x < 0) {
                p.x = width; 
                p.y = Math.random() * height;
            }
        });

        // 4. Sparks Update
        for (let i = sparks.length - 1; i >= 0; i--) {
            let s = sparks[i];
            s.x += s.vx;
            s.y += s.vy;
            s.life -= 0.05;
            if (s.life <= 0) sparks.splice(i, 1);
        }

        // Screen Shake decay
        if (shakeIntensity > 0) shakeIntensity *= 0.9;
        
        frameCount++;
    }

    function draw() {
        // Handle Shake Offset
        let shakeX = (Math.random() - 0.5) * shakeIntensity;
        let shakeY = (Math.random() - 0.5) * shakeIntensity;

        ctx.save();
        ctx.translate(shakeX, shakeY);

        ctx.clearRect(0, 0, width, height);

        // Draw HUD Text Updates
        distDisplay.innerText = Math.floor(distance).toString().padStart(4, '0') + "m";

        // 1. Draw Grid / Wires
        ctx.strokeStyle = '#1b8a0a';
        ctx.lineWidth = 2;
        
        // Top Wire
        ctx.beginPath();
        ctx.moveTo(0, 50);
        ctx.lineTo(width, 50);
        ctx.stroke();

        // Bottom Wire
        ctx.beginPath();
        ctx.moveTo(0, height - 50);
        ctx.lineTo(width, height - 50);
        ctx.stroke();

        // Moving Vertical Grid Lines (Perspective trick)
        let gridOffset = -(distance * 10) % 100;
        ctx.strokeStyle = '#0f4d05'; // Darker
        ctx.lineWidth = 1;
        for (let gx = gridOffset; gx < width; gx += 100) {
            if (gx < 0) continue;
            ctx.beginPath();
            ctx.moveTo(gx, 0);
            ctx.lineTo(gx, height);
            ctx.stroke();
        }

        // 2. Draw Dust (Speed Lines)
        particles.forEach(p => {
            ctx.fillStyle = `rgba(57, 255, 20, ${p.alpha})`;
            ctx.fillRect(p.x, p.y, p.w, p.h);
        });

        // 3. Draw Player
        if (isActive || shakeIntensity > 0) { // Keep drawing briefly after death
            // Trail
            ctx.beginPath();
            for(let i=0; i<player.trail.length; i++){
                let point = player.trail[i];
                if(i===0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            }
            ctx.lineWidth = player.size;
            ctx.strokeStyle = `rgba(57, 255, 20, 0.3)`;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Main Body (Glowing Square)
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            const size = player.size;
            ctx.fillRect(player.x - size/2, player.y - size/2, size, size);
            
            // Core
            ctx.fillStyle = '#fff';
            ctx.fillRect(player.x - size/4, player.y - size/4, size/2, size/2);
            ctx.shadowBlur = 0; // Reset
        }

        // 4. Draw Obstacles (Glitched Blocks)
        obstacles.forEach(obs => {
            // Flicker effect
            if(Math.random() > 0.1) {
                ctx.fillStyle = obs.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = obs.color;
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                
                // Draw digital noise inside
                ctx.fillStyle = '#000';
                ctx.fillRect(obs.x + 5, obs.y + 5, 5, 5);
                ctx.fillRect(obs.x + 20, obs.y + 40, 10, 2);
                ctx.shadowBlur = 0;
            }
        });

        // 5. Draw Sparks
        sparks.forEach(s => {
            ctx.fillStyle = s.color;
            ctx.globalAlpha = s.life;
            ctx.fillRect(s.x, s.y, 3, 3);
            ctx.globalAlpha = 1.0;
        });

        ctx.restore();

        requestAnimationFrame(draw);
    }

    function loop() {
        update();
        requestAnimationFrame(loop);
    }

    // Start
    startBtn.addEventListener('click', () => {
        Audio.init();
        menuOverlay.style.display = 'none';
        resetGame();
    });

    loop();
    draw(); // Start render loop immediately

</script>
  </body>
  
